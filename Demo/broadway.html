<!DOCTYPE html>
<html>
<head>
  <link type="text/css" href="screen.css" rel="stylesheet" />
  <link type="text/css" href="jquery/theme/jquery-ui.css" rel="stylesheet" />
</head>
<body>
  <script type="text/javascript" src="jquery/jquery.min.js"></script>
  <script type="text/javascript" src="jquery/jquery-ui.min.js"></script>
  <script type='text/javascript'>
    var Module = {
        noInitialRun : true
    };
  </script>
  
  <script src="sylvester.js" type="text/javascript"></script>
  <script src="glUtils.js" type="text/javascript"></script>
  <script src='util.js' type='text/javascript'></script>
  <script src='canvas.js' type='text/javascript'></script>
  <script src='broadway.js' type='text/javascript'></script>

  <script type="text/javascript">
    $(function() {
      $("#scrubber").slider({
        range: false,
        min: 0,
        max: 500,
        value: 0,
        slide: function( event, ui ) {
          var pos = ui.value / 500;
          _setPosition(pos);
        }
      });
      
      $("#tabs").tabs();
      $("#play").button();
      $("#play").click(function() {
        play(getConfig());
      });
      
      
      $("#benchmark").button();
      $("#benchmark").click(function() {
        $("#clip").val("mozilla_story.264");
        $("#mode").val("none");
        play(getConfig());
      });
    });

    function downloadFile(file, callback) {
      var xhr = new XMLHttpRequest();
      var async = callback ? true : false;
      xhr.open("GET", file, async);
      xhr.responseType = "arraybuffer";
      xhr.onreadystatechange = function (event) {
        if (xhr.readyState === 4) {
          callback(xhr.response);
        }
      }
      xhr.send(null);
      if (!async) {
        return xhr.response;
      }
    }
    
    function load(config) {
      QUANTUM_SIZE = 4;
      
      document.getElementById('downloadProgress').innerHTML = "Downloading, Please Wait ...";
      
      downloadFile(config.clip, function (buffer) {
        if (buffer) {
          var byteArray = new Uint8Array(buffer);
          var array = Array.prototype.slice.apply(byteArray);
          Module.FS.ignorePermissions = true;
          Module.FS.createDataFile('/', 'video.264', array, true, false);
        } else {
          alert('Cannot load file: ' + config.clip);  
          return;
        }
        
        document.getElementById('downloadProgress').innerHTML = "Download Complete, Playing ...";
        
        // Pass canvas and context to the generated code, and do the actual run() here
        Module.canvas = document.getElementById('canvas');

        if (config.mode == "none") {
          Module.paint = function() {};
        } else if (config.mode == "webgl") {
          Module.paint = webGLPaint;
        } else {
          Module.ctx2D = Module.canvas.getContext('2d');
          if (!Module.ctx2D) {
            alert('Canvas not available :(');
            return;
          }
        }
        
        if (config.deblocking == "none") {
          Module.filter = function() {};
        } else if (config.deblocking == "optimized") {
          Module.filter = Module.defaultFilter;
        } else if (config.deblocking == "default") {
          Module.filter = Module.defaultFilter;
        }
        
        if (config.filterHorLuma == "none") {
          _FilterHorLuma = function (a, b, e, c) { };
        } else if (config.filterHorLuma == "optimized") {
          _FilterHorLuma = OptimizedFilterHorLuma;
        }
        
        if (config.filterVerLumaEdge == "none") {
          _FilterVerLumaEdge = function (a, b, e, c) { };
        } else if (config.filterHorLuma == "optimized") {
          _FilterVerLumaEdge = OptimizedFilterVerLumaEdge;
        }
        
        if (config.getBoundaryStrengths == "none") {
          _GetBoundaryStrengthsA = function (a, b) { };
        } else if (config.getBoundaryStrengths == "optimized") {
          _GetBoundaryStrengthsA = OptimizedGetBoundaryStrengthsA;
        }
        
        console.info("Running: " + config.clip);
        Module.run(['video.264']);
        loaded = true;
        playing = true;
        Module.play();
      });
    }
    
    var loaded = false;
    var playing = false;
    
    function getConfig() {
      return  {clip: $("#clip").val(),
               mode: $("#mode").val(),
               deblocking: $("#deblocking").val(),
               filterHorLuma: $("#filterHorLuma").val(),
               filterVerLumaEdge: $("#filterVerLumaEdge").val(),
               getBoundaryStrengths: $("#getBoundaryStrengths").val()
              };
    }
    
    function play(config) {
      if (!loaded) {
        load(config);
      } else {
        if (playing == false) {
          $('#play').children().first().html("Pause");
          playing = true;
          Module.play();
        } else {
          Module['CorrectionsMonitor'].print();
          $('#play').children().first().html("Play");
          playing = false;
          Module.stop();
          return;
        }
      }
    }

    var webGLCanvas = null;

    var videoFrameCounter = 0;
    var windowFrameCounter = 0;
    var videoStartTime;
    var windowStartTime;
    var scoreFrameCount = 1200;
    var scoreCalculated = false;

    var warmupTime = 1000;
    var fpsMin = 1000;
    var fpsMax = -1000;
    
    Module.onFrameDecoded = function() {
      videoFrameCounter += 1;
      windowFrameCounter += 1;
      var now = Date.now();
      if (!videoStartTime) {
        videoStartTime = now;
      }
      var videoElapsedTime = now - videoStartTime;  

      if (videoElapsedTime < warmupTime) {
        return;
      }
      
      if (!windowStartTime) {
        windowStartTime = now;
      } else if ((now - windowStartTime) > 1000) {
        var windowElapsedTime = now - windowStartTime;
        var fps = (windowFrameCounter / windowElapsedTime) * 1000;
        document.getElementById('fps').innerHTML = fps.toFixed(2);
        windowStartTime = now;
        windowFrameCounter = 0;
        
        if (fps < fpsMin) fpsMin = fps;
        if (fps > fpsMax) fpsMax = fps;
        document.getElementById('fpsMinMax').innerHTML = fpsMin.toFixed(2) + " / " + fpsMax.toFixed(2);
      }
      
      if (videoFrameCounter % 10 == 0) {
        var fps = (videoFrameCounter / videoElapsedTime) * 1000;
        document.getElementById('fpsSinceStart').innerHTML = fps.toFixed(2);
        document.getElementById('upload').innerHTML = (uploadTime / videoFrameCounter).toFixed(2) + "ms";
        document.getElementById('elapsed').innerHTML = (videoElapsedTime / 1000).toFixed(2) + "s";
        
      }
      
      if (!scoreCalculated) {
        if (videoFrameCounter % 10 == 0) {
          document.getElementById('score').innerHTML = "Calculating: " + (scoreFrameCount - videoFrameCounter);
        }
        
        if (videoFrameCounter == scoreFrameCount) {
          var fps = (videoFrameCounter / videoElapsedTime) * 1000;
          document.getElementById('score').innerHTML = fps.toFixed(2);
          scoreCalculated = true;

          var details = "Clip: " + $("#clip").val() + ", Mode: " + $("#mode").val();
          details += ", Deblocking: " + $("#deblocking").val();
          details += ", FilterHorLuma: " + $("#filterHorLuma").val();
          details += ", FilterVerLumaEdge: " + $("#filterVerLumaEdge").val();
          details += ", Elapsed: " + (videoElapsedTime / 1000).toFixed(2) + "s";
          details += ", Score: " + fps.toFixed(2);
          
          onScoreCalculated ({elapsed: videoElapsedTime, score: fps, min: fpsMin, max: fpsMax});
        }
      }
    }
    
    function onScoreCalculated(result) {
      console.info(result);
    }
    
    function updateScrubber() {
      $("#scrubber").slider('value', _getPosition() * 500);
    }
    
    var uploadTime = 0;
    function webGLPaint($luma, $cb, $cr, width, height) {
      if (!webGLCanvas) {
        webGLCanvas = new YUVWebGLCanvas(Module.canvas, new Size(width, height));
      }
      var luma = Module.HEAPU8.subarray($luma);
      var cb = Module.HEAPU8.subarray($cb);
      var cr = Module.HEAPU8.subarray($cr);
    
      var start = Date.now();
      webGLCanvas.YTexture.fill(luma);
      webGLCanvas.UTexture.fill(cb);
      webGLCanvas.VTexture.fill(cr);
      webGLCanvas.drawScene();
      uploadTime += Date.now() - start;
    }
    
    var defaultFilterHorLuma = _FilterHorLuma;
    var defaultFilterVerLumaEdge = _FilterVerLumaEdge;
    var defaultGetBoundaryStrengthsA = _GetBoundaryStrengthsA;
    
    _abs = Math.abs;
    
    function clip(x, y, z) {
      return z < x ? x : (z > y ? y : z);
    }
    
    function OptimizedGetBoundaryStrengthsA($mb, $bS) {
      var $totalCoeff = $mb + 28;
      
      var tc0 = HEAP16[$totalCoeff + 0 >> 1];
      var tc1 = HEAP16[$totalCoeff + 2 >> 1];
      var tc2 = HEAP16[$totalCoeff + 4 >> 1];
      var tc3 = HEAP16[$totalCoeff + 6 >> 1];
      var tc4 = HEAP16[$totalCoeff + 8 >> 1];
      var tc5 = HEAP16[$totalCoeff + 10 >> 1];
      var tc6 = HEAP16[$totalCoeff + 12 >> 1];
      var tc7 = HEAP16[$totalCoeff + 14 >> 1];
      var tc8 = HEAP16[$totalCoeff + 16 >> 1];
      var tc9 = HEAP16[$totalCoeff + 18 >> 1];
      var tc10 = HEAP16[$totalCoeff + 20 >> 1];
      var tc11 = HEAP16[$totalCoeff + 22 >> 1];
      var tc12 = HEAP16[$totalCoeff + 24 >> 1];
      var tc13 = HEAP16[$totalCoeff + 26 >> 1];
      var tc14 = HEAP16[$totalCoeff + 28 >> 1];
      var tc15 = HEAP16[$totalCoeff + 30 >> 1];
      
      HEAP32[$bS + 32 >> 2] = tc2 || tc0 ? 2 : 0;
      HEAP32[$bS + 40 >> 2] = tc3 || tc1 ? 2 : 0;
      HEAP32[$bS + 48 >> 2] = tc6 || tc4 ? 2 : 0;
      HEAP32[$bS + 56 >> 2] = tc7 || tc5 ? 2 : 0;
      HEAP32[$bS + 64 >> 2] = tc8 || tc2 ? 2 : 0;
      HEAP32[$bS + 72 >> 2] = tc9 || tc3 ? 2 : 0;
      HEAP32[$bS + 80 >> 2] = tc12 || tc6 ? 2 : 0;
      HEAP32[$bS + 88 >> 2] = tc13 || tc7 ? 2 : 0;
      HEAP32[$bS + 96 >> 2] = tc10 || tc8 ? 2 : 0;
      HEAP32[$bS + 104 >> 2] = tc11 || tc9 ? 2 : 0;
      HEAP32[$bS + 112 >> 2] = tc14 || tc12 ? 2 : 0;
      HEAP32[$bS + 120 >> 2] = tc15 || tc13 ? 2 : 0;

      HEAP32[$bS + 12 >> 2] = tc1 || tc0 ? 2 : 0;
      HEAP32[$bS + 20 >> 2] = tc4 || tc1 ? 2 : 0;
      HEAP32[$bS + 28 >> 2] = tc5 || tc4 ? 2 : 0;
      HEAP32[$bS + 44 >> 2] = tc3 || tc2 ? 2 : 0;
      HEAP32[$bS + 52 >> 2] = tc6 || tc3 ? 2 : 0;
      HEAP32[$bS + 60 >> 2] = tc7 || tc6 ? 2 : 0;
      HEAP32[$bS + 76 >> 2] = tc9 || tc8 ? 2 : 0;
      HEAP32[$bS + 84 >> 2] = tc12 || tc9 ? 2 : 0;
      HEAP32[$bS + 92 >> 2] = tc13 || tc12 ? 2 : 0;
      HEAP32[$bS + 108 >> 2] = tc11 || tc10 ? 2 : 0;
      HEAP32[$bS + 116 >> 2] = tc14 || tc11 ? 2 : 0;
      HEAP32[$bS + 124 >> 2] = tc15 || tc14 ? 2 : 0;
    }
    
    function OptimizedFilterVerLumaEdge ($data, bS, $thresholds, imageWidth) {
      var delta, tc, tmp;
      var p0, q0, p1, q1, p2, q2;
      var tmpFlag;
      var $clp = _h264bsdClip + 512;
      var alpha = HEAP32[$thresholds + 4 >> 2];
      var beta = HEAP32[$thresholds + 8 >> 2];
      var val;
      
      if (bS < 4) {
        tmp = tc = HEAPU8[HEAP32[$thresholds >> 2] + (bS - 1)] & 255;
        for (var i = 4; i > 0; i--) {
          p1 = HEAPU8[$data + -2] & 255;
          p0 = HEAPU8[$data + -1] & 255;
          q0 = HEAPU8[$data] & 255;
          q1 = HEAPU8[$data + 1] & 255;
          if ((Math.abs(p0 - q0) < alpha) && (Math.abs(p1 - p0) < beta) && (Math.abs(q1 - q0) < beta)) {
            p2 = HEAPU8[$data - 3] & 255;
            if (Math.abs(p2 - p0) < beta) {
              val = (p2 + ((p0 + q0 + 1) >> 1) - (p1 << 1)) >> 1;
              HEAP8[$data - 2] = p1 + clip(-tc, tc, val);
              tmp++;
            }
            
            q2 = HEAPU8[$data + 2] & 255;
            if (Math.abs(q2 - q0) < beta) {
              val = (q2 + ((p0 + q0 + 1) >> 1) - (q1 << 1)) >> 1;
              HEAP8[$data + 1] = (q1 + clip(-tc, tc, val));
              tmp++;
            }
            
            val = ((((q0 - p0) << 2) + (p1 - q1) + 4) >> 3);
            delta = clip(-tmp, tmp, val);
            
            p0 = HEAPU8[$clp + (p0 + delta)] & 255;
            q0 = HEAPU8[$clp + (q0 - delta)] & 255;
            tmp = tc;
            HEAP8[$data - 1] = p0;
            HEAP8[$data] = q0;
            
            $data += imageWidth;
          }
        }
      } else {
        defaultFilterVerLumaEdge($data, bS, $thresholds, imageWidth);
      }
    }
    
    /**
     * Filter all four successive horizontal 4-pixel luma edges. This can
     * be done when bS is equal to all four edges.
     */
    function OptimizedFilterHorLuma ($data, bS, $thresholds, imageWidth) {
      var delta, tc, tmp;
      var p0, q0, p1, q1, p2, q2;
      var tmpFlag;
      var $clp = _h264bsdClip + 512;
      var alpha = HEAP32[$thresholds + 4 >> 2];
      var beta = HEAP32[$thresholds + 8 >> 2];
      var val;
      
      if (bS < 4) {
        tmp = tc = HEAPU8[HEAP32[$thresholds >> 2] + (bS - 1)] & 255;
        for (var i = 16; i > 0; i--) {
          p1 = HEAPU8[$data + (-imageWidth << 1)] & 255;
          p0 = HEAPU8[$data + -imageWidth] & 255;
          q0 = HEAPU8[$data] & 255;
          q1 = HEAPU8[$data + imageWidth] & 255;
          
          if ((Math.abs(p0 - q0) < alpha) && (Math.abs(p1 - p0) < beta) && (Math.abs(q1 - q0) < beta)) {
            p2 = HEAPU8[$data + (-imageWidth * 3)] & 255;
            if (Math.abs(p2 - p0) < beta) {
              val = (p2 + ((p0 + q0 + 1) >> 1) - (p1 << 1)) >> 1;
              HEAP8[$data + (-imageWidth << 1)] = p1 + clip(-tc, tc, val);
              tmp++;
            }
            
            q2 = HEAPU8[$data + (imageWidth << 2)] & 255;
            if (Math.abs(q2 - q0) < beta) {
                val = (q2 + ((p0 + q0 + 1) >> 1) - (q1 << 1)) >> 1;
                HEAP8[$data + imageWidth] = (q1 + clip(-tc, tc, val));
                tmp++;
            }
            
            val = ((((q0 - p0) << 2) + (p1 - q1) + 4) >> 3);
            delta = clip(-tmp, tmp, val);
            
            p0 = HEAPU8[$clp + (p0 + delta)] & 255;
            q0 = HEAPU8[$clp + (q0 - delta)] & 255;
            tmp = tc;
            HEAP8[$data - imageWidth] = p0;
            HEAP8[$data] = q0;
            
            $data ++;
          }
        }
      } else {
        defaultFilterHorLuma($data, bS, $thresholds, imageWidth);
      }
    }
  </script>
  
  <style>
    body {
        margin: 0px;
    }
    #panel {
        background-color: #333333;
        padding: 10px;
        width: 260px;
        height: 900px;
        color: #FFFFFF;
        float: left;
    }
    #panel .title {
        font: normal 36px/.738 MetaBlack, "Arial Black", sans-serif;
        color: #16C0F0;
    }
    #panel .sub-title {
        font: 1.5em Georgia, sans-serif;
    }
    #document {
        float: left;
        background-color: #AAAAAA;
        height: 900px;
        padding: 10px;
    }
    .header {
        font: normal 16px "Arial Black", sans-serif;
        color: #16C0F0;
        margin-bottom: 4px;
    }
  </style>
  
  <div id="panel">
      <p class="title"><b>Broadway.js</b></p>
      <p class="sub-title">An H.264 Decoder in JavaScript</p>
      
      <p class="header">Settings</p>
      <div id="setting">
        <span>Clip:</span> 
        <select id="clip" style="margin-left: 10px;">
          <option value="mozilla.264">Mozilla</option>
          <option value="mozilla_story.264">Mozilla Story</option>
          <option value="admiral.264">Admiral</option>
          <option value="matrix.264">Matrix SD</option>
          <option value="matrix_large.264">Matrix HD</option>
        </select>
      </div>
      <div id="setting">
        <span>Render Mode:</span>
        <select id="mode" style="margin-left: 10px;">
          <option value="canvas">Canvas</option>
          <option value="webgl">Canvas w/ WebGL</option>
          <option value="none">None</option>
        </select> 
      </div>
      <div id="setting">
        <span>Deblocking Filter:</span> 
        <select id="deblocking" style="margin-left: 10px;">
          <option value="default">Default</option>
          <option value="none">None</option> 
        </select> 
      </div>
      
      <div id="setting">
        <span style="margin-left: 10px;">Hor Luma:</span>
        <select id="filterHorLuma" style="margin-left: 10px;">
          <option value="default">Default</option>
          <option value="optimized" selected>Optimized</option>
          <option value="none">None</option> 
        </select>
      </div>
      
      <div id="setting">
        <span style="margin-left: 10px;">Ver Luma Edge: </span>
        <select id="filterVerLumaEdge" style="margin-left: 10px;">
          <option value="default">Default</option>
          <option value="optimized" selected>Optimized</option>
          <option value="none">None</option> 
        </select>
      </div>
      
      <div id="setting">
        <span style="margin-left: 10px;">Boundary Strengths: </span>
        <select id="getBoundaryStrengths" style="margin-left: 10px;">
          <option value="default">Default</option>
          <option value="optimized" selected>Optimized</option>
          <option value="none">None</option> 
        </select>
      </div>
      
      <div id="setting">
        <button id="play" style="margin-right: 8px">Play</button>
        <button id="benchmark">Benchmark</button>
      </div>
      
      
      <div id="setting">
        <div id="downloadProgress"></div>
      </div>
      
      <!-- Stats -->
      <div style="margin-top: 30px">
      <p class="header">Statistics</p>
      <table style="width: 100%; clear: both;">
        <tr>
          <th>FPS</th>
          <td><span id='fps'></span></td>
        </tr>
        <tr>
          <th>Average FPS</th>
          <td><span id='fpsSinceStart'></span></td>
        </tr>
        <tr>
          <th>Min / Max</th>
          <td><span id='fpsMinMax'></span></td>
        </tr>
        <tr>
          <th>Upload Speed</th>
          <td><span id='upload'></span></td>
        </tr>
        <tr>
          <th>Elapsed</th>
          <td><span id='elapsed'></span></td>
        </tr>
        <tr>
          <th>Score</th>
          <td><span id='score'></span></td>
        </tr>
        <tr>
          <td colspan="2" style="font-weight: normal; padding-left: 0px; text-align: left;"><span id='score-details'></span></td>
        </tr>
      </table>
      </div>
      
  </div>

  <div id="document">
    <div id="player" style="background-color: black; float: left;">
      <canvas id='canvas' width="640" height="100" style="background-color: #333333;"></canvas>
      <div id="controls">
        <div id="scrubber"></div>
      </div>
    </div>  
  </body>
</html>